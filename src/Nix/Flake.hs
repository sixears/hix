{-# LANGUAGE UnicodeSyntax #-}
module Nix.Flake
  ( FlakePkg
  , FlakePkgs
  , HasArchFlakePkgMap(archMap)
  , flakePkgMap
  , flakePkgMap'
  , flakeShow
  , flakeShowNM
  , forMX86_64Pkg
  , forMX86_64Pkg_
  , forX86_64Pkg
  , location
  , pkg
  , pkgFindNames
  , pkgFindNames'
  , priority
  , tests
  , ver
  , x86_64
  , x86_64_
  , x86_64_pkgs
  ) where

import Base1T


import Prelude ( undefined )

-- aeson -------------------------------

import Data.Aeson ( eitherDecodeStrict' )

import Data.Aeson.Types as AesonTypes

-- aeson-plus --------------------------

import Data.Aeson.Error ( AsAesonError, throwAsAesonError )

-- base --------------------------------

import Control.Monad      ( foldM )
import Control.Monad.Fail ( MonadFail(fail) )
import Data.Function      ( flip )
import Data.Maybe         ( catMaybes, fromMaybe )
import Data.Monoid        ( Monoid )
import Data.Tuple         ( uncurry )
import GHC.Generics       ( Generic )

-- containers --------------------------

import Data.Map.Strict qualified as Map

-- fpath -------------------------------

import FPath.AbsFile          ( AbsFile )
import FPath.AppendableFPath  ( (‚´ª) )
import FPath.AsFilePath       ( filepath )
import FPath.Error.FPathError ( AsFPathError )
import FPath.File             ( File, FileAs(_File_) )
import FPath.RelFile          ( relfile )

-- lens --------------------------------

import Control.Lens.At     ( at )
import Control.Lens.Getter ( view )
import Control.Lens.Tuple  ( _2 )

-- log-plus ----------------------------

import Log ( Log )

-- logging-effect ----------------------

import Control.Monad.Log ( MonadLog, Severity(Notice) )

-- mockio ------------------------------

import MockIO.DoMock ( DoMock(NoMock) )

-- mockio-log --------------------------

import MockIO.IOClass ( HasIOClass, IOClass(IORead, IOWrite) )
import MockIO.Log     ( HasDoMock, MockIOClass )

-- mockio-plus -------------------------

import MockIO.OpenFile          ( readFileY )
import MockIO.Process.MLCmdSpec ( MLCmdSpec, mock_value )

-- monadio-plus ------------------------

import MonadIO.Error.CreateProcError ( AsCreateProcError )
import MonadIO.Error.ProcExitError   ( AsProcExitError )
import MonadIO.NamedHandle           ( HGetContents(hGetContents),
                                       HWriteContents(hWriteContents), ‚Ñç,
                                       impliedEncoding, impliedEncodingM )
import MonadIO.Process.ExitStatus    ( ExitStatus, evOK )

-- more-unicode ------------------------

import Data.MoreUnicode.Lens ( (‚ä©) )

-- mtl ---------------------------------

import Control.Monad.Reader ( MonadReader, runReaderT )

-- parsers -----------------------------

import Text.Parser.Char ( char )

-- text --------------------------------

import Data.Text          ( concat, intercalate, pack, unpack )
import Data.Text.Encoding ( encodeUtf8 )

-- text-printer ------------------------

import Text.Printer qualified as P

-- textual-plus ------------------------

import TextualPlus                         ( PrintOut, TextualPlus(textual'),
                                             parseT, parseTextual, tparse )
import TextualPlus.Error.TextualParseError ( AsTextualParseError )

------------------------------------------------------------
--                     local imports                      --
------------------------------------------------------------

import Nix                ( nixDo )
import Nix.Error          ( AsNixDuplicatePkgError, AsNixError,
                            throwAsNixDuplicatePkgError,
                            throwAsNixErrorDuplicatePkg )
import Nix.Types          ( Arch, ConfigDir(unConfigDir), Pkg, Priority,
                            RemoteState, Ver, pkgRE, remoteArgs, unPriority,
                            x86_64Linux )
import Nix.Types.AttrPath ( AttrPath, mkAttrPath )

--------------------------------------------------------------------------------

data FlakePkg = FlakePkg { _description :: ùïÑ ùïã
                         , _pkg         :: Pkg
                         , _ver         :: ùïÑ Ver
                         , _type        :: ùïã
                           -- priority isn't really in the flake, it's in our
                           -- own flake.priorities
                         , _priority    :: ùïÑ Priority
                         }
  deriving (Eq, Generic, Show)

pkg ‚à∑ Lens' FlakePkg Pkg
pkg = lens _pkg (\ fp p ‚Üí (fp { _pkg = p }))

ver ‚à∑ Lens' FlakePkg (ùïÑ Ver)
ver = lens _ver (\ fp v ‚Üí (fp { _ver = v }))

priority ‚à∑ Lens' FlakePkg (ùïÑ Priority)
priority = lens _priority (\ fp p ‚Üí (fp { _priority = p }))

pkgVer ‚à∑ FlakePkg ‚Üí ùïã
pkgVer f =
  let p = toText $ f ‚ä£ pkg
  in  case f ‚ä£ ver of
        ùïπ   ‚Üí p
        ùïµ v ‚Üí [fmt|%t-%T|] p v

instance FromJSON FlakePkg where
  parseJSON =
    withObject "FlakePkg" $
    \ v ‚Üí do
          name ‚Üê v .: "name"
          (p,vers) ‚Üê parseT pkgRE "FlakePkg" (unpack name)
          FlakePkg ‚ä≥ v .:? "description" ‚äµ return p ‚äµ return vers ‚äµ v .: "type"
                   -- when reading the flake show output, priority is always ùïπ
                   -- as we read this from flake.priorities
                   ‚äµ pure ùïπ
instance Printable FlakePkg where
  print = P.text ‚àò pkgVer

------------------------------------------------------------

type Map = Map.Map

newtype FlakePkgs' = FlakePkgs' { unFlakePkgs' :: Map Arch (Map Pkg FlakePkg) }
  deriving (Eq, Generic, Show)

instance FromJSON FlakePkgs' where
  parseJSON =
    withObject "FlakePkgs'" $ \ v ‚Üí
    {- let customOptions ‚à∑ AesonTypes.Options
        customOptions =
          let dropLeadingUnderscore ('_' : s) = s
              dropLeadingUnderscore s         = s
          in  defaultOptions { fieldLabelModifier = dropLeadingUnderscore }
    in -} FlakePkgs' ‚ä≥ v .: "packages"


class HasArchFlakePkgMap Œ± where
  archMap ‚à∑ Lens' Œ± (Map Arch (Map Pkg FlakePkg))

instance HasArchFlakePkgMap (Map Arch (Map Pkg FlakePkg)) where
  archMap = id

instance HasArchFlakePkgMap FlakePkgs' where
  archMap = lens unFlakePkgs' (\ _ m ‚Üí FlakePkgs' m)

updatePriorities' ‚à∑ PkgPriorities ‚Üí FlakePkgs' ‚Üí FlakePkgs'
updatePriorities' pkgprios (FlakePkgs' fps) =
  FlakePkgs' (Map.map (Map.map undefined) fps)

--------------------

data FlakePkgs = FlakePkgs { _location :: ConfigDir
                           , _packages :: FlakePkgs'
                           }
  deriving (Show)

location ‚à∑ Lens' FlakePkgs ConfigDir
location = lens _location (\ fp l ‚Üí fp { _location = l })

packages ‚à∑ Lens' FlakePkgs (Map.Map Arch (Map.Map Pkg FlakePkg))
packages = lens (unFlakePkgs' ‚àò _packages)
                (\ p f ‚Üí (p { _packages = FlakePkgs' f }))

instance HasArchFlakePkgMap FlakePkgs where
  archMap = packages ‚àò archMap

instance Printable FlakePkgs where
  print fp =
    let namePkg ‚à∑ Arch ‚Üí (Map.Map Pkg FlakePkg) ‚Üí [ùïã]
        namePkg arch pkgs = [ [fmt|packages.%T.%T|] arch p
                              | (p,_) ‚Üê Map.toList pkgs ]
    in P.text $
    intercalate " ‚´Ω " [ intercalate "," (namePkg arch pkgs)
                        | (arch,pkgs) ‚Üê Map.toList (fp ‚ä£ packages) ]

----------------------------------------

updatePriorities ‚à∑ PkgPriorities ‚Üí FlakePkgs ‚Üí FlakePkgs
updatePriorities (PkgPriorities pps) fps =
  let go ‚à∑ (Pkg,Priority) ‚Üí FlakePkgs ‚Üí FlakePkgs
      go (p,y) fpkgs = fpkgs & packages ‚äß Map.map (Map.adjust(& priority ‚ä© y) p)
  in  foldr go fps (Map.toList pps)

----------------------------------------

locFile ‚à∑ FlakePkgs ‚Üí AbsFile
locFile fp = (unConfigDir $ _location fp) ‚´ª [relfile|flake.nix|]

----------------------------------------

priosFile ‚à∑ ConfigDir ‚Üí AbsFile
priosFile fp = (unConfigDir fp) ‚´ª [relfile|flake.priorities|]

----------------------------------------

x86_64 ‚à∑ FlakePkgs ‚Üí ùïÑ (Map.Map Pkg FlakePkg)
x86_64 f = (f ‚ä£ packages) ‚ä£ at x86_64Linux

x86_64_ ‚à∑ Lens' FlakePkgs (Map.Map Pkg FlakePkg)
x86_64_ = go x86_64Linux
  where go ‚à∑ Arch ‚Üí Lens' FlakePkgs (Map.Map Pkg FlakePkg)
        go a =
          let pkgs ‚à∑ Lens' FlakePkgs (Map.Map Arch (Map.Map Pkg FlakePkg))
              pkgs = lens (unFlakePkgs' ‚àò _packages)
                          (\ p f ‚Üí (p { _packages = FlakePkgs' f }))
              f1 ‚à∑ Map.Map Arch (Map.Map Pkg FlakePkg) ‚Üí Map.Map Pkg FlakePkg
              f1 fps = fromMaybe Map.empty $ a `Map.lookup` fps
              f2 ‚à∑ Map.Map Arch (Map.Map Pkg FlakePkg) ‚Üí Map.Map Pkg FlakePkg
                 ‚Üí Map.Map Arch (Map.Map Pkg FlakePkg)
              f2 fps new = Map.insert a new fps
          in  pkgs ‚àò (lens f1 f2)

----------------------------------------

{-| apply a function to each named `FlakePkg` in x86_64-linux packages -}
forX86_64Pkg ‚à∑ FlakePkgs ‚Üí (Pkg ‚Üí FlakePkg ‚Üí Œ±) ‚Üí [Œ±]
forX86_64Pkg fps f = case x86_64 fps of
  ùïµ pkg_map ‚Üí (uncurry f) ‚ä≥ (Map.toList pkg_map)
  ùïπ         ‚Üí []

----------------------------------------

{-| monadic apply a function to each named `FlakePkg` in x86_64-linux
    packages -}
forMX86_64Pkg ‚à∑ Monad Œ∑ ‚áí FlakePkgs ‚Üí (Pkg ‚Üí FlakePkg ‚Üí Œ∑ Œ±) ‚Üí Œ∑ [Œ±]
forMX86_64Pkg fps f = case x86_64 fps of
  ùïµ pkg_map ‚Üí forM (Map.toList pkg_map) (uncurry f)
  ùïπ         ‚Üí return []

----------------------------------------

{-| monadic apply a function to each named `FlakePkg` in x86_64-linux
    packages; unify unit returns -}
forMX86_64Pkg_ ‚à∑ Monad Œ∑ ‚áí FlakePkgs ‚Üí (Pkg ‚Üí FlakePkg ‚Üí Œ∑ Œ±) ‚Üí Œ∑ ()
forMX86_64Pkg_ fps f = forMX86_64Pkg fps f ‚™º return ()

----------------------------------------

pkgFind ‚à∑ FlakePkgs ‚Üí Pkg ‚Üí [(Arch,FlakePkg)]
pkgFind fp p =
  catMaybes [ (a,) ‚ä≥ p `Map.lookup` m | (a,m) ‚Üê Map.toList (fp ‚ä£ packages) ]

----------------------------------------

pkgName ‚à∑ (Arch,FlakePkg) ‚Üí AttrPath
pkgName (arch,fp) = mkAttrPath (fp ‚ä£ pkg) ["packages", (toText arch)]

----------------------------------------

pkgFindName_ ‚à∑ (MonadError Œµ Œ∑) ‚áí
               (Pkg ‚Üí AbsFile ‚Üí Œ∑ (ùïÑ AttrPath)) ‚Üí FlakePkgs ‚Üí Pkg
             ‚Üí Œ∑ (ùïÑ AttrPath)
pkgFindName_ t fp p = case pkgFind fp p of
                     []    ‚Üí return ùïπ
                     [afp] ‚Üí return $ ùïµ (pkgName afp)
                     _     ‚Üí t p (locFile fp)

--------------------

pkgFindName ‚à∑ (AsNixDuplicatePkgError Œµ, MonadError Œµ Œ∑) ‚áí
              FlakePkgs ‚Üí Pkg ‚Üí Œ∑ (ùïÑ AttrPath)
pkgFindName = pkgFindName_ throwAsNixDuplicatePkgError

--------------------

pkgFindName' ‚à∑ (AsNixError Œµ, MonadError Œµ Œ∑) ‚áí FlakePkgs ‚Üí Pkg ‚Üí Œ∑ (ùïÑ AttrPath)
pkgFindName' = pkgFindName_ throwAsNixErrorDuplicatePkg

----------------------------------------

pkgFindNames_ ‚à∑ (Traversable œà, MonadError Œµ Œ∑) ‚áí
                (FlakePkgs ‚Üí Pkg ‚Üí Œ∑ (ùïÑ AttrPath)) ‚Üí FlakePkgs ‚Üí œà Pkg
              ‚Üí Œ∑ (œà (Pkg, ùïÑ AttrPath))
pkgFindNames_ f fp = mapM (\ p ‚Üí (p,) ‚ä≥ f fp p)

pkgFindNames ‚à∑ (Traversable œà, AsNixDuplicatePkgError Œµ, MonadError Œµ Œ∑) ‚áí
               FlakePkgs ‚Üí œà Pkg ‚Üí Œ∑ (œà (Pkg, ùïÑ AttrPath))
pkgFindNames = pkgFindNames_ pkgFindName

pkgFindNames' ‚à∑ (Traversable œà, AsNixError Œµ, MonadError Œµ Œ∑) ‚áí
                FlakePkgs ‚Üí œà Pkg ‚Üí Œ∑ (œà (Pkg, ùïÑ AttrPath))
pkgFindNames' = pkgFindNames_ pkgFindName'

----------------------------------------

flakeShowTestInput ‚à∑ ùïã
flakeShowTestInput =
  concat [ "{ \"packages\": {"
         , "    \"x86_64-linux\": {"

         , "      \"binutils\": {"
         , "        \"description\": \"MOCK MOCK MOCK\","
         , "        \"name\": \"binutils-wrapper-2.38\","
         , "        \"type\": \"derivation\""
         , "      },"

         , "      \"get-iplayer-config\": {"
         , "        \"name\": \"get-iplayer-config\","
         , "        \"type\": \"derivation\""
         , "      },"

         , "      \"graph-easy\": {"
         , "        \"description\": \"MOCK MOCKETY MOCK\","
         , "        \"name\": \"perl5.34.1-Graph-Easy-0.76\","
         , "        \"type\": \"derivation\""
         , "      }"

         , "    }"
         , "  }"
         , "}"
         ]

--------------------

flakeShowTestMap ‚à∑ Map.Map Pkg FlakePkg
flakeShowTestMap = fromList [ ("binutils",
                               FlakePkg { _description = ùïµ "MOCK MOCK MOCK"
                                        , _pkg = "binutils-wrapper"
                                        , _ver = Just "2.38"
                                        , _type = "derivation"
                                        , _priority = ùïπ
                                        })
                            , ("get-iplayer-config",
                               FlakePkg { _description = ùïπ
                                        , _pkg = "get-iplayer-config"
                                        , _ver = ùïπ
                                        , _type = "derivation"
                                        , _priority = ùïπ
                                        })
                            , ("graph-easy",
                               FlakePkg { _description = ùïµ "MOCK MOCKETY MOCK"
                                        , _pkg = "perl5.34.1-Graph-Easy"
                                        , _ver = ùïµ "0.76"
                                        , _type = "derivation"
                                        , _priority = ùïπ
                                        })
                            ]

----------------------------------------

{-| nix flake show #flake -}
flakeShow ‚à∑ ‚àÄ Œµ Œ¥ Œº .
            (MonadIO Œº, HasDoMock Œ¥, MonadReader Œ¥ Œº,
             AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ,
             AsTextualParseError Œµ, AsProcExitError Œµ, AsAesonError Œµ,
             Printable Œµ, MonadError Œµ Œº,
             MonadLog (Log MockIOClass) Œº) ‚áí
            RemoteState ‚Üí ConfigDir ‚Üí Œº FlakePkgs
flakeShow r d = do
  let eAsAesonError ‚à∑ (Printable œÑ,AsAesonError Œµ,MonadError Œµ Œ∑) ‚áí ùîº œÑ Œ≤ ‚Üí Œ∑ Œ≤
      eAsAesonError = either throwAsAesonError return
      mock_set ‚à∑ MLCmdSpec ùïã ‚Üí MLCmdSpec ùïã
      mock_set = let mock_val ‚à∑ (ExitStatus, ùïã) = (evOK, flakeShowTestInput)
                 in  (& mock_value ‚ä¢ mock_val)
      args     = —é [ ["flake", "show", "--json" ]
                   , remoteArgs r
                   , [ pack $ (unConfigDir d) ‚´• filepath ] ]
--  (_,flake_show) ‚Üê Íô© (Paths.nix, args, [”≠ (”ô "NIX_CONFIG")], mock_set)
  flake_show ‚Üê nixDo (ùïµ mock_set) args
  x ‚à∑ FlakePkgs ‚Üê eAsAesonError (FlakePkgs d ‚ä≥ eitherDecodeStrict' (encodeUtf8 flake_show))
  prios ‚Üê readPriorities (priosFile d)
  return (updatePriorities prios x)

----------------------------------------

{-| `flakeShowNM`, never mock -}
flakeShowNM ‚à∑ ‚àÄ Œµ Œº .
              (MonadIO Œº,
               AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ,
               AsProcExitError Œµ, AsAesonError Œµ, AsTextualParseError Œµ,
               Printable Œµ, MonadError Œµ Œº,
               MonadLog (Log MockIOClass) Œº) ‚áí
              RemoteState ‚Üí ConfigDir ‚Üí Œº FlakePkgs
flakeShowNM r = flip runReaderT NoMock ‚àò flakeShow r

----------------------------------------

flakeDecodeTests ‚à∑ TestTree
flakeDecodeTests =
  testCase "flakeDecode" $
    ùïΩ (FlakePkgs' $ Map.fromList [("x86_64-linux",flakeShowTestMap)] ) @=?
      eitherDecodeStrict' (encodeUtf8 flakeShowTestInput)

----------------------------------------

{-| Convert to a Map from `Pkg` to full addressable name in the flake, e.g.,
    "packages.x86_64-linux.cabal" -}
flakePkgMap_ ‚à∑ ‚àÄ Œµ Œ∑ . MonadError Œµ Œ∑ ‚áí
              (‚àÄ œâ . Pkg ‚Üí AbsFile ‚Üí Œ∑ œâ) ‚Üí FlakePkgs ‚Üí Œ∑ (Map.Map Pkg ùïã)
flakePkgMap_ throw fp =
  let throwDup k _ _ = throw k (locFile fp)
  in  sequence $ Map.fromListWithKey throwDup
        [ (p,return $ [fmt|packages.%T.%T|] arch p)
        | (arch,pkgs) ‚Üê Map.toList (fp ‚ä£ packages), (p,_) ‚Üê Map.toList pkgs ]

flakePkgMap ‚à∑ ‚àÄ Œµ Œ∑ . (AsNixDuplicatePkgError Œµ, MonadError Œµ Œ∑) ‚áí
              FlakePkgs ‚Üí Œ∑ (Map.Map Pkg ùïã)
flakePkgMap = flakePkgMap_ throwAsNixDuplicatePkgError

flakePkgMap' ‚à∑ ‚àÄ Œµ Œ∑ . (AsNixError Œµ, MonadError Œµ Œ∑) ‚áí
               FlakePkgs ‚Üí Œ∑ (Map.Map Pkg ùïã)
flakePkgMap' = flakePkgMap_ throwAsNixErrorDuplicatePkg

newtype PkgPriority = PkgPriority { unPkgPriority :: (Pkg, Priority) }
  deriving (Show)

instance Printable PkgPriority where
  print (PkgPriority (k,r)) = P.text $ [fmt|%T:%d|] k (unPriority r)

instance TextualPlus PkgPriority where
  textual' = let tabs = some $ char '\t'
             in  PkgPriority ‚ä≥ (((,) ‚ä≥ textual' ‚ã™ tabs ‚äµ textual'))

newtype PkgPriorities = PkgPriorities (Map.Map Pkg Priority)
  deriving (Show)

pkgPrioritiesFromList ‚à∑ MonadFail Œ∑ ‚áí [PkgPriority] ‚Üí Œ∑ PkgPriorities
pkgPrioritiesFromList pkps =
  let go ‚à∑ MonadFail Œ∑ ‚áí
           Map.Map Pkg Priority ‚Üí PkgPriority ‚Üí Œ∑ (Map.Map Pkg Priority)
      go pps (PkgPriority (p,y)) = case p `Map.lookup` pps of
                                     ùïπ ‚Üí return $ Map.insert p y pps
  in  PkgPriorities ‚ä≥ foldM go Map.empty pkps
{-
  let xx ‚à∑ PkgPriority ‚Üí (Pkg,[Priority])
      xx = _
      -- A map from Pkg to all the priorities it's associated with
      -- (including duplicates)
      proto_map ‚à∑ Map.Map Pkg [Priority]
      proto_map = Map.fromListWith _ (xx ‚ä≥ pkps)
      go pkg [prio] accum =
        case accum of
          ùï∑ errs ‚Üí errs
          ùïΩ accum' ‚Üí case pkg `Map.lookup` accum' of
                       ùïπ   ‚Üí ùïΩ (_ ‚à∑ Map.Map Pkg Priority)
                       ùïµ _ ‚Üí ùï∑ (_ ‚à∑ Map.Map Pkg [Priority])
      go pkg prios accum =
        case accum of
          ùï∑ errs ‚Üí _
          ùïΩ accum' ‚Üí case pkg `Map.lookup` accum' of
                       ùïπ   ‚Üí ùïΩ (_ ‚à∑ Map.Map Pkg Priority)
                       ùïµ _ ‚Üí ùï∑ (_ ‚à∑ Map.Map Pkg [Priority])
-- XXX could this be foldMapWithKey?
  in case Map.foldrWithKey go (return $ Map.empty) proto_map of
    ùï∑ e ‚Üí fail $ _ e
    ùïΩ r ‚Üí return $ PkgPriorities r
-}

instance Printable PkgPriorities where
  print (PkgPriorities pps) =
    P.text ‚àò intercalate "\n" $ toText ‚àò PkgPriority ‚ä≥ Map.toList pps

instance TextualPlus PkgPriorities where
  -- textual' = pkgPrioritiesFromList ‚ä≥ many (textual' ‚ã™ char '\n')
  textual' = many (textual' ‚ã™ char '\n') ‚â´ pkgPrioritiesFromList

readPriorities ‚à∑ ‚àÄ Œµ Œ≥ œâ Œº .
                 (HasDoMock œâ, HasIOClass œâ,
                  Default œâ, MonadLog (Log œâ) Œº, MonadError Œµ Œº, AsIOError Œµ,
               AsTextualParseError Œµ,
                  FileAs Œ≥, MonadIO Œº, Printable Œµ) ‚áí
                 Œ≥ ‚Üí Œº PkgPriorities

readPriorities f =
  let fmsg ‚à∑ ùïÑ (File ‚Üí ùïã)
      fmsg = ùïµ [fmt|reading priorities: %T|]
  in  readFileY @_ @ùïã Notice fmsg —Ñ f NoMock ‚â´ tparse ‚àò fromMaybe ""

----------------------------------------

x86_64_pkgs ‚à∑ FlakePkgs ‚Üí [Pkg]
x86_64_pkgs fp = case x86_64 fp of
                   ùïπ   ‚Üí []
                   ùïµ m ‚Üí Map.keys m

-- tests -----------------------------------------------------------------------

{-| unit tests -}
tests ‚à∑ TestTree
tests =
  testGroup "Nix.Flake"
    [ flakeDecodeTests ]

_test ‚à∑ IO ExitCode
_test = runTestTree tests

_tests ‚à∑ ùïä ‚Üí IO ExitCode
_tests = runTestsP tests

_testr ‚à∑ ùïä ‚Üí ‚Ñï ‚Üí IO ExitCode
_testr = runTestsReplay tests

-- that's all, folks! ----------------------------------------------------------
