{-# LANGUAGE UnicodeSyntax #-}
module Nix.Flake
  ( FlakePkg
  , FlakePkgs
  , flakePkgMap
  , flakePkgMap'
  , flakeShow
  , flakeShowNM
  , forMX86_64Pkg
  , forMX86_64Pkg_
  , forX86_64Pkg
  , location
  , namePkgVersPrioSrcArch
  , pkg
  , pkgFindNames
  , pkgFindNames'
  , priority
  , tests
  , ver
  , x86_64
  , x86_64_
  , x86_64_pkgs
  ) where

import Base1T

-- aeson -------------------------------

import Data.Aeson ( eitherDecodeStrict' )

-- aeson-plus --------------------------

import Data.Aeson.Error ( AsAesonError )

-- base --------------------------------

import Control.Monad.Fail ( MonadFail(fail) )
import Data.Function      ( flip )
import Data.Maybe         ( catMaybes, fromMaybe )
import Data.Tuple         ( uncurry )

-- containers --------------------------

import Data.Map.Strict qualified as Map

-- fpath -------------------------------

import FPath.AbsFile          ( AbsFile )
import FPath.AppendableFPath  ( (‚´ª) )
import FPath.Error.FPathError ( AsFPathError )
import FPath.File             ( File, FileAs )
import FPath.RelFile          ( relfile )

-- lens --------------------------------

import Control.Lens.At ( at )

-- log-plus ----------------------------

import Log ( Log )

-- logging-effect ----------------------

import Control.Monad.Log ( MonadLog, Severity(Notice) )

-- mockio ------------------------------

import MockIO.DoMock ( DoMock(NoMock) )

-- mockio-log --------------------------

import MockIO.IOClass ( HasIOClass )
import MockIO.Log     ( HasDoMock, MockIOClass )

-- mockio-plus -------------------------

import MockIO.OpenFile ( readFileY )

-- monadio-plus ------------------------

import MonadIO.Error.CreateProcError ( AsCreateProcError )
import MonadIO.Error.ProcExitError   ( AsProcExitError )

-- more-unicode ------------------------

import Data.MoreUnicode.Lens ( (‚ä©) )

-- mtl ---------------------------------

import Control.Monad.Reader ( MonadReader, runReaderT )

-- parsers -----------------------------

import Text.Parser.Char ( char )

-- text --------------------------------

import Data.Text          ( intercalate )
import Data.Text.Encoding ( encodeUtf8 )

-- text-printer ------------------------

import Text.Printer qualified as P

-- textual-plus ------------------------

import TextualPlus                         ( TextualPlus(textual'), tparse )
import TextualPlus.Error.TextualParseError ( AsTextualParseError )

-- tuple-plus --------------------------

import Data.TuplePlus ( (‚®§), (‚®¶) )

------------------------------------------------------------
--                     local imports                      --
------------------------------------------------------------

import Nix.Error           ( AsNixDuplicatePkgError, AsNixError,
                             throwAsNixDuplicatePkgError,
                             throwAsNixErrorDuplicatePkg )
import Nix.NixExe          ( nixFlakeShow )
import Nix.Types           ( Arch, Pkg, Priority, RemoteState, unPriority,
                             x86_64Linux )
import Nix.Types.AttrPath  ( AttrPath, mkAttrPath )
import Nix.Types.ConfigDir ( ConfigDir(unConfigDir) )
import Nix.Types.FlakePkgs ( FlakePkg, FlakePkgs, FlakePkgs'(FlakePkgs'),
                             archMap, flakeShowTestInput, flakeShowTestMap,
                             location, packages, pkg, priority, ver )

--------------------------------------------------------------------------------

updatePriorities ‚à∑ PkgPriorities ‚Üí FlakePkgs ‚Üí FlakePkgs
updatePriorities (PkgPriorities pps) fps =
  let go ‚à∑ (Pkg,Priority) ‚Üí FlakePkgs ‚Üí FlakePkgs
      go (p,y) fpkgs = fpkgs & packages ‚äß Map.map (Map.adjust(& priority ‚ä© y) p)
  in  foldr go fps (Map.toList pps)

----------------------------------------

locFile ‚à∑ FlakePkgs ‚Üí AbsFile
locFile fp = (unConfigDir $ fp ‚ä£ location) ‚´ª [relfile|flake.nix|]

----------------------------------------

priosFile ‚à∑ ConfigDir ‚Üí AbsFile
priosFile fp = (unConfigDir fp) ‚´ª [relfile|flake.priorities|]

----------------------------------------

x86_64 ‚à∑ FlakePkgs ‚Üí ùïÑ (Map.Map Pkg FlakePkg)
x86_64 f = (f ‚ä£ packages) ‚ä£ at x86_64Linux

x86_64_ ‚à∑ Lens' FlakePkgs (Map.Map Pkg FlakePkg)
x86_64_ = go x86_64Linux
  where go ‚à∑ Arch ‚Üí Lens' FlakePkgs (Map.Map Pkg FlakePkg)
        go a =
          let f1 ‚à∑ Map.Map Arch (Map.Map Pkg FlakePkg) ‚Üí Map.Map Pkg FlakePkg
              f1 fps = fromMaybe Map.empty $ a `Map.lookup` fps
              f2 ‚à∑ Map.Map Arch (Map.Map Pkg FlakePkg) ‚Üí Map.Map Pkg FlakePkg
                 ‚Üí Map.Map Arch (Map.Map Pkg FlakePkg)
              f2 fps new = Map.insert a new fps
          in  packages ‚àò (lens f1 f2)

----------------------------------------

{-| apply a function to each named `FlakePkg` in x86_64-linux packages -}
forX86_64Pkg ‚à∑ FlakePkgs ‚Üí (Pkg ‚Üí FlakePkg ‚Üí Œ±) ‚Üí [Œ±]
forX86_64Pkg fps f = case x86_64 fps of
  ùïµ pkg_map ‚Üí (uncurry f) ‚ä≥ (Map.toList pkg_map)
  ùïπ         ‚Üí []

----------------------------------------

{-| monadic apply a function to each named `FlakePkg` in x86_64-linux
    packages -}
forMX86_64Pkg ‚à∑ Monad Œ∑ ‚áí FlakePkgs ‚Üí (Pkg ‚Üí FlakePkg ‚Üí Œ∑ Œ±) ‚Üí Œ∑ [Œ±]
forMX86_64Pkg fps f = case x86_64 fps of
  ùïµ pkg_map ‚Üí forM (Map.toList pkg_map) (uncurry f)
  ùïπ         ‚Üí return []

----------------------------------------

{-| monadic apply a function to each named `FlakePkg` in x86_64-linux
    packages; unify unit returns -}
forMX86_64Pkg_ ‚à∑ Monad Œ∑ ‚áí FlakePkgs ‚Üí (Pkg ‚Üí FlakePkg ‚Üí Œ∑ Œ±) ‚Üí Œ∑ ()
forMX86_64Pkg_ fps f = forMX86_64Pkg fps f ‚™º return ()

----------------------------------------

pkgFind ‚à∑ FlakePkgs ‚Üí Pkg ‚Üí [(Arch,FlakePkg)]
pkgFind fp p =
  catMaybes [ (a,) ‚ä≥ p `Map.lookup` m | (a,m) ‚Üê Map.toList (fp ‚ä£ packages) ]

----------------------------------------

pkgName ‚à∑ (Arch,FlakePkg) ‚Üí (AttrPath, ùïÑ Priority)
pkgName (arch,fp) = (mkAttrPath (fp ‚ä£ pkg) ["packages", (toText arch)],
                     fp‚ä£priority)

----------------------------------------

pkgFindName_ ‚à∑ ‚àÄ Œµ Œ∑ . (MonadError Œµ Œ∑) ‚áí
               (Pkg ‚Üí AbsFile ‚Üí Œ∑ (ùïÑ (AttrPath,ùïÑ Priority))) ‚Üí FlakePkgs ‚Üí Pkg
             ‚Üí Œ∑ (ùïÑ (AttrPath, ùïÑ Priority))
pkgFindName_ t fp p = case pkgFind fp p of
                     []    ‚Üí return ùïπ
                     [afp] ‚Üí return $ ùïµ (pkgName afp)
                     _     ‚Üí t p (locFile fp)

--------------------

pkgFindName ‚à∑ (AsNixDuplicatePkgError Œµ, MonadError Œµ Œ∑) ‚áí
              FlakePkgs ‚Üí Pkg ‚Üí Œ∑ (ùïÑ (AttrPath, ùïÑ Priority))
pkgFindName = pkgFindName_ throwAsNixDuplicatePkgError

--------------------

pkgFindName' ‚à∑ (AsNixError Œµ, MonadError Œµ Œ∑) ‚áí
               FlakePkgs ‚Üí Pkg ‚Üí Œ∑ (ùïÑ (AttrPath, ùïÑ Priority))
pkgFindName' = pkgFindName_ throwAsNixErrorDuplicatePkg

----------------------------------------

pkgFindNames_ ‚à∑ (Traversable œà, MonadError Œµ Œ∑) ‚áí
                (FlakePkgs ‚Üí Pkg ‚Üí Œ∑ (ùïÑ (AttrPath, (ùïÑ Priority))))
              ‚Üí FlakePkgs ‚Üí œà Pkg ‚Üí Œ∑ (œà (Pkg, ùïÑ (AttrPath, (ùïÑ Priority))))
pkgFindNames_ f fp = mapM (\ p ‚Üí (p,) ‚ä≥ f fp p)

pkgFindNames ‚à∑ (Traversable œà, AsNixDuplicatePkgError Œµ, MonadError Œµ Œ∑) ‚áí
               FlakePkgs ‚Üí œà Pkg ‚Üí Œ∑ (œà (Pkg, ùïÑ (AttrPath, (ùïÑ Priority))))
pkgFindNames = pkgFindNames_ pkgFindName

pkgFindNames' ‚à∑ (Traversable œà, AsNixError Œµ, MonadError Œµ Œ∑) ‚áí
                FlakePkgs ‚Üí œà Pkg ‚Üí Œ∑ (œà (Pkg, ùïÑ (AttrPath, (ùïÑ Priority))))
pkgFindNames' = pkgFindNames_ pkgFindName'

----------------------------------------

{-| nix flake show #flake -}
flakeShow ‚à∑ ‚àÄ Œµ Œ¥ Œº .
            (MonadIO Œº, HasDoMock Œ¥, MonadReader Œ¥ Œº,
             AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ,
             AsTextualParseError Œµ, AsProcExitError Œµ, AsAesonError Œµ,
             Printable Œµ, MonadError Œµ Œº,
             MonadLog (Log MockIOClass) Œº) ‚áí
            RemoteState ‚Üí ConfigDir ‚Üí Œº FlakePkgs
flakeShow r d = do
  flake_pkgs ‚Üê nixFlakeShow r d
  prios ‚Üê readPriorities (priosFile d)
  return (updatePriorities prios flake_pkgs)

----------------------------------------

{-| `flakeShowNM`, never mock -}
flakeShowNM ‚à∑ ‚àÄ Œµ Œº .
              (MonadIO Œº,
               AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ,
               AsProcExitError Œµ, AsAesonError Œµ, AsTextualParseError Œµ,
               Printable Œµ, MonadError Œµ Œº,
               MonadLog (Log MockIOClass) Œº) ‚áí
              RemoteState ‚Üí ConfigDir ‚Üí Œº FlakePkgs
flakeShowNM r = flip runReaderT NoMock ‚àò flakeShow r

----------------------------------------

flakeDecodeTests ‚à∑ TestTree
flakeDecodeTests =
  testCase "flakeDecode" $
    ùïΩ (FlakePkgs' $ Map.fromList [("x86_64-linux",flakeShowTestMap)] ) @=?
      eitherDecodeStrict' (encodeUtf8 flakeShowTestInput)

----------------------------------------

{-| Convert to a Map from `Pkg` to full addressable name in the flake, e.g.,
    "packages.x86_64-linux.cabal" -}
flakePkgMap_ ‚à∑ ‚àÄ Œµ Œ∑ . MonadError Œµ Œ∑ ‚áí
              (‚àÄ œâ . Pkg ‚Üí AbsFile ‚Üí Œ∑ œâ) ‚Üí FlakePkgs ‚Üí Œ∑ (Map.Map Pkg ùïã)
flakePkgMap_ throw fp =
  let throwDup k _ _ = throw k (locFile fp)
  in  sequence $ Map.fromListWithKey throwDup
        [ (p,return $ [fmt|packages.%T.%T|] arch p)
        | (arch,pkgs) ‚Üê Map.toList (fp ‚ä£ packages), (p,_) ‚Üê Map.toList pkgs ]

flakePkgMap ‚à∑ ‚àÄ Œµ Œ∑ . (AsNixDuplicatePkgError Œµ, MonadError Œµ Œ∑) ‚áí
              FlakePkgs ‚Üí Œ∑ (Map.Map Pkg ùïã)
flakePkgMap = flakePkgMap_ throwAsNixDuplicatePkgError

flakePkgMap' ‚à∑ ‚àÄ Œµ Œ∑ . (AsNixError Œµ, MonadError Œµ Œ∑) ‚áí
               FlakePkgs ‚Üí Œ∑ (Map.Map Pkg ùïã)
flakePkgMap' = flakePkgMap_ throwAsNixErrorDuplicatePkg

newtype PkgPriority = PkgPriority { unPkgPriority :: (Pkg, Priority) }
  deriving (Show)

instance Printable PkgPriority where
  print (PkgPriority (k,r)) = P.text $ [fmt|%T:%d|] k (unPriority r)

instance TextualPlus PkgPriority where
  textual' = let tabs = some $ char '\t'
             in  PkgPriority ‚ä≥ (((,) ‚ä≥ textual' ‚ã™ tabs ‚äµ textual'))

newtype PkgPriorities = PkgPriorities (Map.Map Pkg Priority)
  deriving (Show)

pkgPrioritiesFromList ‚à∑ MonadFail Œ∑ ‚áí [PkgPriority] ‚Üí Œ∑ PkgPriorities
pkgPrioritiesFromList pkps =
  let go ‚à∑ MonadFail Œ∑ ‚áí
           Map.Map Pkg Priority ‚Üí PkgPriority ‚Üí Œ∑ (Map.Map Pkg Priority)
      go pps (PkgPriority (p,y)) =
        case p `Map.lookup` pps of
          ùïπ ‚Üí return $ Map.insert p y pps
          ùïµ y' ‚Üí fail $ [fmt|duplicate priorities found for %T: (%T,%T)|] p y y'
  in  PkgPriorities ‚ä≥ foldM go Map.empty pkps
{-
  let xx ‚à∑ PkgPriority ‚Üí (Pkg,[Priority])
      xx = _
      -- A map from Pkg to all the priorities it's associated with
      -- (including duplicates)
      proto_map ‚à∑ Map.Map Pkg [Priority]
      proto_map = Map.fromListWith _ (xx ‚ä≥ pkps)
      go pkg [prio] accum =
        case accum of
          ùï∑ errs ‚Üí errs
          ùïΩ accum' ‚Üí case pkg `Map.lookup` accum' of
                       ùïπ   ‚Üí ùïΩ (_ ‚à∑ Map.Map Pkg Priority)
                       ùïµ _ ‚Üí ùï∑ (_ ‚à∑ Map.Map Pkg [Priority])
      go pkg prios accum =
        case accum of
          ùï∑ errs ‚Üí _
          ùïΩ accum' ‚Üí case pkg `Map.lookup` accum' of
                       ùïπ   ‚Üí ùïΩ (_ ‚à∑ Map.Map Pkg Priority)
                       ùïµ _ ‚Üí ùï∑ (_ ‚à∑ Map.Map Pkg [Priority])
-- XXX could this be foldMapWithKey?
  in case Map.foldrWithKey go (return $ Map.empty) proto_map of
    ùï∑ e ‚Üí fail $ _ e
    ùïΩ r ‚Üí return $ PkgPriorities r
-}

instance Printable PkgPriorities where
  print (PkgPriorities pps) =
    P.text ‚àò intercalate "\n" $ toText ‚àò PkgPriority ‚ä≥ Map.toList pps

instance TextualPlus PkgPriorities where
  -- textual' = pkgPrioritiesFromList ‚ä≥ many (textual' ‚ã™ char '\n')
  textual' = many (textual' ‚ã™ char '\n') ‚â´ pkgPrioritiesFromList

readPriorities ‚à∑ ‚àÄ Œµ Œ≥ œâ Œº .
                 (HasDoMock œâ, HasIOClass œâ,
                  Default œâ, MonadLog (Log œâ) Œº, MonadError Œµ Œº, AsIOError Œµ,
               AsTextualParseError Œµ,
                  FileAs Œ≥, MonadIO Œº, Printable Œµ) ‚áí
                 Œ≥ ‚Üí Œº PkgPriorities

readPriorities f =
  let fmsg ‚à∑ ùïÑ (File ‚Üí ùïã)
      fmsg = ùïµ [fmt|reading priorities: %T|]
  in  readFileY @_ @ùïã Notice fmsg —Ñ f NoMock ‚â´ tparse ‚àò fromMaybe ""

----------------------------------------

x86_64_pkgs ‚à∑ FlakePkgs ‚Üí [Pkg]
x86_64_pkgs fp = case x86_64 fp of
                   ùïπ   ‚Üí []
                   ùïµ m ‚Üí Map.keys m

----------------------------------------

namePkgVersPrioSrcArch ‚à∑ FlakePkgs ‚Üí [(ùïã,ùïã,ùïã,ùïã,ùïã,ùïã)]
namePkgVersPrioSrcArch pkgs =
  let
    pkg_ver ‚à∑ FlakePkg ‚Üí (ùïã,ùïã,ùïã)
    pkg_ver fp = (toText $ fp ‚ä£ pkg, maybe "" toText $ fp ‚ä£ ver,
                  maybe "" toText $ fp ‚ä£ priority)

    go ‚à∑ Pkg ‚Üí FlakePkg ‚Üí [(ùïã,ùïã,ùïã,ùïã,ùïã)]
    go p fp = [(toText p ‚®§ (pkg_ver fp) ‚à∑ (ùïã,ùïã,ùïã,ùïã)) ‚®¶ toText (pkgs ‚ä£ location)]
    go' ‚à∑ Arch ‚Üí Map.Map Pkg FlakePkg ‚Üí [(ùïã,ùïã,ùïã,ùïã,ùïã,ùïã)]
    go' arch fpmap = (‚®¶ (toText arch)) ‚ä≥ Map.foldMapWithKey go fpmap
  in
    Map.foldMapWithKey go' (pkgs ‚ä£ archMap)

-- tests -----------------------------------------------------------------------

{-| unit tests -}
tests ‚à∑ TestTree
tests =
  testGroup "Nix.Flake"
    [ flakeDecodeTests ]

_test ‚à∑ IO ExitCode
_test = runTestTree tests

_tests ‚à∑ ùïä ‚Üí IO ExitCode
_tests = runTestsP tests

_testr ‚à∑ ùïä ‚Üí ‚Ñï ‚Üí IO ExitCode
_testr = runTestsReplay tests

-- that's all, folks! ----------------------------------------------------------
